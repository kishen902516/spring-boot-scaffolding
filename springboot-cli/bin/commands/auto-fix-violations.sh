#!/bin/bash

# Auto-Fix Architecture Violations Script
# Applies auto-correction rules to fix common Clean Architecture violations

set -e

# Script directory and paths
SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
CLI_DIR="$(dirname "$(dirname "$SCRIPT_DIR")")"
CONFIG_FILE="$CLI_DIR/config/auto-correction-rules.yaml"
TEMPLATES_DIR="$CLI_DIR/templates"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
NC='\033[0m' # No Color

# Counters
TOTAL_FILES_CHECKED=0
TOTAL_VIOLATIONS_FOUND=0
TOTAL_FIXES_APPLIED=0
TOTAL_FIXES_FAILED=0

# Project directory (default to current)
PROJECT_DIR="${1:-.}"

# Function to print colored output
print_color() {
    echo -e "${2}${1}${NC}"
}

# Function to fix missing interface implementation
fix_missing_interface() {
    local file="$1"
    local class_name=$(basename "$file" .java)

    print_color "  Fixing missing interface for $class_name" "$YELLOW"

    # Extract package
    local package=$(grep "^package" "$file" | sed 's/package //;s/;//')
    local domain_package=$(echo "$package" | sed 's/infrastructure.*/domain/')

    # Determine port name and package
    local port_name="${class_name%Client}Port"
    if [[ "$class_name" =~ RepositoryImpl$ ]]; then
        port_name="${class_name%Impl}"
    elif [[ "$class_name" =~ Adapter$ ]]; then
        port_name="${class_name%Adapter}Port"
    fi

    local port_type="outbound"
    if [[ "$class_name" =~ Repository ]]; then
        port_type="outbound"
    fi

    local port_package="${domain_package}.port.${port_type}"
    local port_path="$PROJECT_DIR/src/main/java/$(echo "$port_package" | tr '.' '/')/${port_name}.java"

    # Create port interface if it doesn't exist
    if [[ ! -f "$port_path" ]]; then
        mkdir -p "$(dirname "$port_path")"

        # Extract public methods from the class
        local methods=$(grep -E "public .* \w+\(.*\)" "$file" | grep -v "class\|@")

        cat > "$port_path" << EOF
package ${port_package};

$(grep "^import" "$file" | grep -v "springframework\|Component\|Repository\|Service" || echo "")

/**
 * Port interface for ${class_name}
 * Auto-generated by Architecture Auto-Fix
 */
public interface ${port_name} {
EOF

        # Add method signatures
        while IFS= read -r method; do
            if [[ -n "$method" ]]; then
                # Convert method to interface signature
                local signature=$(echo "$method" | sed 's/{$/;/' | sed 's/public /    /' | sed 's/@Override//')
                echo "$signature" >> "$port_path"
            fi
        done <<< "$methods"

        echo "}" >> "$port_path"

        print_color "    Created port interface: $port_name" "$GREEN"
    fi

    # Update class to implement the interface
    if ! grep -q "implements $port_name" "$file"; then
        sed -i "s/public class ${class_name}/public class ${class_name} implements ${port_name}/" "$file"

        # Add import for the port
        if ! grep -q "import ${port_package}.${port_name}" "$file"; then
            sed -i "/^package/a\\\nimport ${port_package}.${port_name};" "$file"
        fi

        # Add @Override annotations to public methods
        sed -i '/public .* \w\+(.*) {/i\    @Override' "$file"

        print_color "    Updated $class_name to implement $port_name" "$GREEN"
        TOTAL_FIXES_APPLIED=$((TOTAL_FIXES_APPLIED + 1))
    fi
}

# Function to fix Spring annotations in domain layer
fix_domain_annotations() {
    local file="$1"
    local class_name=$(basename "$file" .java)

    print_color "  Removing Spring annotations from domain class $class_name" "$YELLOW"

    # Backup original file
    cp "$file" "${file}.backup"

    # Create JPA entity in infrastructure if needed
    if grep -q "@Entity" "$file"; then
        local package=$(grep "^package" "$file" | sed 's/package //;s/;//')
        local infra_package=$(echo "$package" | sed 's/domain.*/infrastructure.adapter.persistence.entity/')
        local jpa_path="$PROJECT_DIR/src/main/java/$(echo "$infra_package" | tr '.' '/')/${class_name}JpaEntity.java"

        mkdir -p "$(dirname "$jpa_path")"

        # Create JPA entity with annotations
        cat > "$jpa_path" << EOF
package ${infra_package};

import javax.persistence.*;
import java.util.UUID;

@Entity
@Table(name = "$(echo "$class_name" | sed 's/\([A-Z]\)/_\1/g' | tr '[:upper:]' '[:lower:]' | sed 's/^_//')s")
public class ${class_name}JpaEntity {
EOF

        # Extract fields and add JPA annotations
        grep -E "private .* \w+;" "$file" | while IFS= read -r field; do
            if echo "$field" | grep -q " id;"; then
                echo "    @Id" >> "$jpa_path"
                echo "    @GeneratedValue(strategy = GenerationType.AUTO)" >> "$jpa_path"
            fi
            echo "    $field" >> "$jpa_path"
        done

        # Add getters and setters
        echo "" >> "$jpa_path"
        echo "    // Getters and setters" >> "$jpa_path"
        echo "}" >> "$jpa_path"

        print_color "    Created JPA entity: ${class_name}JpaEntity" "$GREEN"

        # Create mapper
        create_mapper "$class_name" "$package" "$infra_package"
    fi

    # Remove Spring/JPA annotations from domain class
    sed -i '/@Entity/d' "$file"
    sed -i '/@Table/d' "$file"
    sed -i '/@Id/d' "$file"
    sed -i '/@GeneratedValue/d' "$file"
    sed -i '/@Column/d' "$file"
    sed -i '/@Component/d' "$file"
    sed -i '/@Service/d' "$file"
    sed -i '/@Repository/d' "$file"
    sed -i '/@Autowired/d' "$file"
    sed -i '/@Value/d' "$file"

    # Remove Spring imports
    sed -i '/import org.springframework/d' "$file"
    sed -i '/import javax.persistence/d' "$file"

    print_color "    Cleaned domain class: $class_name" "$GREEN"
    TOTAL_FIXES_APPLIED=$((TOTAL_FIXES_APPLIED + 1))
}

# Function to create mapper between domain and JPA entity
create_mapper() {
    local entity_name="$1"
    local domain_package="$2"
    local infra_package="$3"

    local mapper_package="${infra_package%entity}mapper"
    local mapper_path="$PROJECT_DIR/src/main/java/$(echo "$mapper_package" | tr '.' '/')/${entity_name}Mapper.java"

    mkdir -p "$(dirname "$mapper_path")"

    cat > "$mapper_path" << EOF
package ${mapper_package};

import ${domain_package}.${entity_name};
import ${infra_package}.${entity_name}JpaEntity;
import org.springframework.stereotype.Component;

/**
 * Mapper between ${entity_name} domain model and JPA entity
 * Auto-generated by Architecture Auto-Fix
 */
@Component
public class ${entity_name}Mapper {

    public ${entity_name} toDomain(${entity_name}JpaEntity entity) {
        if (entity == null) return null;

        // TODO: Implement proper mapping
        return new ${entity_name}();
    }

    public ${entity_name}JpaEntity toEntity(${entity_name} domain) {
        if (domain == null) return null;

        ${entity_name}JpaEntity entity = new ${entity_name}JpaEntity();
        // TODO: Implement proper mapping
        return entity;
    }

    public void updateEntity(${entity_name} domain, ${entity_name}JpaEntity entity) {
        if (domain == null || entity == null) return;

        // TODO: Implement update logic
    }
}
EOF

    print_color "    Created mapper: ${entity_name}Mapper" "$GREEN"
}

# Function to fix business logic in wrong layer
fix_business_logic_placement() {
    local file="$1"
    local layer=$(echo "$file" | grep -o "api\|infrastructure\|application")

    if [[ "$layer" == "api" ]] || [[ "$layer" == "infrastructure" ]]; then
        print_color "  Moving business logic from $layer layer" "$YELLOW"

        # Extract suspicious business logic patterns
        local has_business_logic=false
        if grep -q "if.*\\.get.*().*[><]" "$file"; then
            has_business_logic=true
        fi

        if [[ "$has_business_logic" == "true" ]]; then
            local class_name=$(basename "$file" .java | sed 's/Controller$//' | sed 's/RepositoryImpl$//' | sed 's/Client$//')
            local package=$(grep "^package" "$file" | sed 's/package //;s/;//')
            local app_package=$(echo "$package" | sed 's/\(.*\)\.\(api\|infrastructure\).*/\1.application/')

            # Create use case for the business logic
            local usecase_path="$PROJECT_DIR/src/main/java/$(echo "$app_package.usecase" | tr '.' '/')/${class_name}UseCase.java"

            mkdir -p "$(dirname "$usecase_path")"

            cat > "$usecase_path" << EOF
package ${app_package}.usecase;

import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

/**
 * Use case containing business logic for ${class_name}
 * Auto-generated by Architecture Auto-Fix
 */
@Service
@Transactional
public class ${class_name}UseCase {

    // TODO: Inject required ports

    public void execute() {
        // TODO: Move business logic here
    }
}
EOF

            print_color "    Created use case: ${class_name}UseCase" "$GREEN"
            print_color "    TODO: Manually move business logic to use case" "$YELLOW"

            TOTAL_FIXES_APPLIED=$((TOTAL_FIXES_APPLIED + 1))
        fi
    fi
}

# Function to make value objects immutable
fix_value_object_immutability() {
    local file="$1"
    local class_name=$(basename "$file" .java)

    if [[ "$file" =~ /vo/ ]] || [[ "$class_name" =~ ValueObject$ ]]; then
        print_color "  Making value object $class_name immutable" "$YELLOW"

        # Make fields final
        sed -i 's/private \([^f]\)/private final \1/g' "$file"

        # Remove setters
        sed -i '/public void set/,/^[[:space:]]*}/d' "$file"

        # Add record-like toString, equals, hashCode if missing
        if ! grep -q "public boolean equals" "$file"; then
            # TODO: Generate equals/hashCode/toString methods
            print_color "    TODO: Add equals/hashCode/toString methods" "$YELLOW"
        fi

        print_color "    Made $class_name immutable" "$GREEN"
        TOTAL_FIXES_APPLIED=$((TOTAL_FIXES_APPLIED + 1))
    fi
}

# Main function to scan and fix violations
scan_and_fix() {
    print_color "\n═══════════════════════════════════════════════════════" "$BLUE"
    print_color "     Architecture Violations Auto-Fix Tool                " "$BLUE"
    print_color "═══════════════════════════════════════════════════════" "$BLUE"
    print_color "\nScanning project: $PROJECT_DIR\n" "$CYAN"

    # Check if project exists
    if [[ ! -d "$PROJECT_DIR/src" ]]; then
        print_color "Error: No src directory found in $PROJECT_DIR" "$RED"
        exit 1
    fi

    # Find all Java files
    local java_files=$(find "$PROJECT_DIR/src/main/java" -name "*.java" 2>/dev/null || true)

    for file in $java_files; do
        TOTAL_FILES_CHECKED=$((TOTAL_FILES_CHECKED + 1))

        # Skip test files
        if [[ "$file" =~ /test/ ]]; then
            continue
        fi

        # Check for missing interface implementation
        if [[ "$file" =~ /infrastructure/adapter/ ]]; then
            if [[ "$file" =~ Client\.java$ ]] || [[ "$file" =~ RepositoryImpl\.java$ ]] || [[ "$file" =~ Adapter\.java$ ]]; then
                if ! grep -q "implements.*Port" "$file"; then
                    print_color "\nViolation: Missing interface in $(basename "$file")" "$RED"
                    TOTAL_VIOLATIONS_FOUND=$((TOTAL_VIOLATIONS_FOUND + 1))
                    fix_missing_interface "$file"
                fi
            fi
        fi

        # Check for Spring annotations in domain
        if [[ "$file" =~ /domain/ ]]; then
            if grep -q "@Entity\|@Component\|@Service\|@Repository\|@Autowired" "$file"; then
                print_color "\nViolation: Spring annotations in domain $(basename "$file")" "$RED"
                TOTAL_VIOLATIONS_FOUND=$((TOTAL_VIOLATIONS_FOUND + 1))
                fix_domain_annotations "$file"
            fi
        fi

        # Check for business logic in wrong layer
        if [[ "$file" =~ /api/.*Controller\.java$ ]] || [[ "$file" =~ /infrastructure/.*RepositoryImpl\.java$ ]]; then
            if grep -q "if.*\\.get.*().*[><]\|calculate\|validate[^R]" "$file"; then
                print_color "\nViolation: Business logic in wrong layer $(basename "$file")" "$RED"
                TOTAL_VIOLATIONS_FOUND=$((TOTAL_VIOLATIONS_FOUND + 1))
                fix_business_logic_placement "$file"
            fi
        fi

        # Check value object immutability
        if [[ "$file" =~ /domain/.*vo/ ]] || [[ "$file" =~ ValueObject\.java$ ]]; then
            if grep -q "public void set" "$file"; then
                print_color "\nViolation: Mutable value object $(basename "$file")" "$RED"
                TOTAL_VIOLATIONS_FOUND=$((TOTAL_VIOLATIONS_FOUND + 1))
                fix_value_object_immutability "$file"
            fi
        fi
    done

    # Print summary
    print_color "\n═══════════════════════════════════════════════════════" "$BLUE"
    print_color "                    Summary Report                       " "$BLUE"
    print_color "═══════════════════════════════════════════════════════" "$BLUE"

    print_color "\nFiles checked:        $TOTAL_FILES_CHECKED" "$CYAN"
    print_color "Violations found:     $TOTAL_VIOLATIONS_FOUND" "$((TOTAL_VIOLATIONS_FOUND > 0 ? YELLOW : GREEN))"
    print_color "Fixes applied:        $TOTAL_FIXES_APPLIED" "$GREEN"
    print_color "Fixes failed:         $TOTAL_FIXES_FAILED" "$((TOTAL_FIXES_FAILED > 0 ? RED : GREEN))"

    if [[ $TOTAL_VIOLATIONS_FOUND -eq 0 ]]; then
        print_color "\n✅ No architecture violations found!" "$GREEN"
    elif [[ $TOTAL_FIXES_APPLIED -eq $TOTAL_VIOLATIONS_FOUND ]]; then
        print_color "\n✅ All violations have been fixed!" "$GREEN"
    else
        local remaining=$((TOTAL_VIOLATIONS_FOUND - TOTAL_FIXES_APPLIED))
        print_color "\n⚠️  $remaining violations require manual intervention" "$YELLOW"
    fi

    # Run architecture validation to verify fixes
    if [[ $TOTAL_FIXES_APPLIED -gt 0 ]]; then
        print_color "\n🔍 Running architecture validation to verify fixes..." "$CYAN"

        if [[ -f "$SCRIPT_DIR/validate-architecture.sh" ]]; then
            "$SCRIPT_DIR/validate-architecture.sh" || {
                print_color "⚠️  Some architecture rules still failing after fixes" "$YELLOW"
            }
        fi
    fi
}

# Show usage
show_usage() {
    echo "Usage: $0 [project-directory]"
    echo ""
    echo "Auto-fixes common Clean Architecture violations:"
    echo "  - Missing port interface implementations"
    echo "  - Spring annotations in domain layer"
    echo "  - Business logic in wrong layers"
    echo "  - Mutable value objects"
    echo ""
    echo "Examples:"
    echo "  $0                    # Fix violations in current directory"
    echo "  $0 /path/to/project   # Fix violations in specific project"
}

# Main entry point
if [[ "$1" == "--help" ]] || [[ "$1" == "-h" ]]; then
    show_usage
    exit 0
fi

# Run scan and fix
scan_and_fix