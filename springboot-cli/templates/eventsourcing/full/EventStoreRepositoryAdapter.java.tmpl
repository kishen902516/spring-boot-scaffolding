package ${PACKAGE}.infrastructure.adapter.persistence.eventstore;

import ${PACKAGE}.domain.event.DomainEvent;
import ${PACKAGE}.domain.exception.ConcurrencyException;
import ${PACKAGE}.domain.port.output.EventStore;
import com.fasterxml.jackson.databind.ObjectMapper;
import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

/**
 * Event Store implementation using JPA/MongoDB.
 *
 * <p>Persists events as serialized JSON in the database.
 * Provides event replay and reconstruction capabilities.
 */
@Component
public class EventStoreRepositoryAdapter implements EventStore {

  private final JpaEventStoreRepository repository;
  private final ObjectMapper objectMapper;
  private final EventTypeRegistry eventTypeRegistry;

  public EventStoreRepositoryAdapter(
      JpaEventStoreRepository repository,
      ObjectMapper objectMapper,
      EventTypeRegistry eventTypeRegistry) {
    this.repository = repository;
    this.objectMapper = objectMapper;
    this.eventTypeRegistry = eventTypeRegistry;
  }

  @Override
  @Transactional
  public void saveEvents(UUID aggregateId, List<DomainEvent> events, long expectedVersion) {
    // Optimistic locking: verify current version
    long currentVersion = repository.findMaxVersionByAggregateId(aggregateId).orElse(0L);

    if (currentVersion != expectedVersion) {
      throw new ConcurrencyException(
          String.format(
              "Aggregate %s has been modified. Expected version %d but found %d",
              aggregateId, expectedVersion, currentVersion));
    }

    // Save each event
    for (DomainEvent event : events) {
      EventEntity entity = toEntity(event);
      repository.save(entity);
    }
  }

  @Override
  public List<DomainEvent> getEvents(UUID aggregateId) {
    return repository.findByAggregateIdOrderByVersionAsc(aggregateId).stream()
        .map(this::toDomainEvent)
        .collect(Collectors.toList());
  }

  @Override
  public List<DomainEvent> getEvents(UUID aggregateId, long fromVersion) {
    return repository.findByAggregateIdAndVersionGreaterThanOrderByVersionAsc(aggregateId, fromVersion)
        .stream()
        .map(this::toDomainEvent)
        .collect(Collectors.toList());
  }

  @Override
  public <T extends DomainEvent> List<T> getEventsByType(Class<T> eventType) {
    String typeName = eventType.getSimpleName();
    return repository.findByEventTypeOrderByTimestampAsc(typeName).stream()
        .map(this::toDomainEvent)
        .filter(eventType::isInstance)
        .map(eventType::cast)
        .collect(Collectors.toList());
  }

  private EventEntity toEntity(DomainEvent event) {
    try {
      EventEntity entity = new EventEntity();
      entity.setEventId(event.getEventId());
      entity.setAggregateId(event.getAggregateId());
      entity.setVersion(event.getAggregateVersion());
      entity.setEventType(event.getEventType());
      entity.setTimestamp(event.getOccurredAt());
      entity.setEventData(objectMapper.writeValueAsString(event));
      return entity;
    } catch (Exception e) {
      throw new RuntimeException("Failed to serialize event", e);
    }
  }

  private DomainEvent toDomainEvent(EventEntity entity) {
    try {
      Class<? extends DomainEvent> eventClass = eventTypeRegistry.getEventClass(entity.getEventType());
      return objectMapper.readValue(entity.getEventData(), eventClass);
    } catch (Exception e) {
      throw new RuntimeException("Failed to deserialize event", e);
    }
  }
}
