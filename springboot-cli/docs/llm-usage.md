# LLM Usage Guide

This guide provides structured prompts and examples for using LLMs (like Claude, ChatGPT) to work with Spring Boot projects generated by this CLI.

## Table of Contents

- [Getting Started](#getting-started)
- [Common Tasks](#common-tasks)
- [Code Understanding](#code-understanding)
- [Testing Prompts](#testing-prompts)
- [Troubleshooting](#troubleshooting)
- [Best Practices](#best-practices)

---

## Getting Started

### Initialize a New Project

**Prompt:**
```
Create a new Spring Boot service called "inventory-service" with the following requirements:
- Package: com.company.inventory
- Database: MongoDB
- Features: OAuth2 security, lightweight event-driven architecture
- OpenAPI spec: [provide path or describe API]

Use the springboot-cli tool to generate the project structure.
```

**Expected Command:**
```bash
./springboot-cli.sh init \
  --name inventory-service \
  --package com.company.inventory \
  --database mongodb \
  --features oauth2,eventsourcing-lite
```

---

## Common Tasks

### Add a Complete Feature (Entity + Use Case + Repository)

**Prompt:**
```
I need to add a "Product" feature to my inventory service with the following:

Entity fields:
- id: UUID
- name: String
- sku: String (unique)
- price: BigDecimal
- quantity: Integer
- lastUpdated: Instant

Use cases:
- CreateProduct: Create a new product
- UpdateProductQuantity: Update quantity for existing product
- GetProduct: Retrieve product by ID or SKU

Repository: MongoDB-based with custom queries for SKU lookup

Please generate the necessary commands and explain the architecture.
```

**Expected Response:**
```bash
# 1. Create the entity
./springboot-cli.sh add entity \
  --name Product \
  --fields "id:UUID,name:String,sku:String,price:BigDecimal,quantity:Integer,lastUpdated:Instant"

# 2. Create use cases
./springboot-cli.sh add usecase --name CreateProduct --aggregate Product
./springboot-cli.sh add usecase --name UpdateProductQuantity --aggregate Product
./springboot-cli.sh add usecase --name GetProduct --aggregate Product

# 3. Create repository
./springboot-cli.sh add repository --entity Product --type mongo

# Architecture:
# - Domain: Product entity in domain/model/entity/
# - Application: Use case implementations in application/usecase/
# - Infrastructure: MongoDB repository in infrastructure/adapter/persistence/mongodb/
# - API: Generated from OpenAPI spec
```

---

### Add External Service Integration

**Prompt:**
```
I need to integrate with a Payment Service API with the following requirements:
- Service name: PaymentService
- Resilience: Circuit breaker, retry (3 attempts), rate limiting
- Operations: charge, refund, getStatus
- Base URL: https://api.payment-provider.com

Generate the client with full resilience patterns.
```

**Expected Command:**
```bash
./springboot-cli.sh add client \
  --name PaymentService \
  --circuit-breaker \
  --retry \
  --rate-limit
```

**Follow-up Prompt:**
```
Now implement the three methods (charge, refund, getStatus) in the PaymentServiceClient
with proper error handling and telemetry tracking.
```

---

### Generate API from OpenAPI Spec

**Prompt:**
```
I have an OpenAPI 3.1 specification at ./openapi/inventory-api.yaml.
Generate the API controllers and DTOs from this spec.
The spec defines:
- GET /api/products
- GET /api/products/{id}
- POST /api/products
- PUT /api/products/{id}
- DELETE /api/products/{id}
```

**Expected Command:**
```bash
./springboot-cli.sh generate openapi --spec ./openapi/inventory-api.yaml
```

---

## Code Understanding

### Understand Clean Architecture Layers

**Prompt:**
```
Explain the clean architecture in this project and how the following code files relate to each other:

1. src/main/java/com/company/inventory/domain/model/entity/Product.java
2. src/main/java/com/company/inventory/domain/port/output/ProductRepository.java
3. src/main/java/com/company/inventory/application/usecase/CreateProductUseCaseImpl.java
4. src/main/java/com/company/inventory/infrastructure/adapter/persistence/mongodb/ProductRepositoryAdapter.java
5. src/main/java/com/company/inventory/api/controller/ProductApiController.java

Show the dependency direction and explain why this architecture is beneficial.
```

---

### Understand Event Flow

**Prompt:**
```
I'm using lightweight event-driven architecture. Explain how events flow through the system when a ProductCreatedEvent is published:

1. Where is the event defined?
2. How is it published?
3. Who handles it?
4. What happens if the handler fails?
5. How is it persisted (outbox pattern)?

Show code examples from my project.
```

---

## Testing Prompts

### Generate Unit Tests

**Prompt:**
```
Generate comprehensive unit tests for the CreateProductUseCase class located at:
src/main/java/com/company/inventory/application/usecase/CreateProductUseCaseImpl.java

The tests should cover:
- Successful product creation
- Validation failures (null name, negative price, etc.)
- Repository exceptions
- Event publication verification
- Telemetry tracking verification

Use Mockito, AssertJ, and follow Given-When-Then structure.
```

---

### Generate Integration Tests

**Prompt:**
```
Generate REST API integration tests for the Product endpoints using REST Assured.
Cover all CRUD operations with:
- Success cases (200, 201, 204)
- Error cases (400, 404, 409)
- Pagination testing
- Validation error responses

Use embedded MongoDB for tests.
```

---

### Add Contract Tests

**Prompt:**
```
I need to create Pact contract tests for:

Provider: inventory-service (this service)
Consumer: order-service (external service that calls us)

The contract should verify:
- GET /api/products/{id} returns product details
- POST /api/products creates a product
- Handle 404 when product not found

Generate the provider contract test.
```

**Expected Command:**
```bash
./springboot-cli.sh generate contract --provider
```

---

## Troubleshooting

### Diagnose Build Failures

**Prompt:**
```
My Maven build is failing with the following error:
[paste error here]

The project uses:
- Java 21
- Spring Boot 3.3.x
- MongoDB
- OAuth2 JWT
- Resilience4j

Help me diagnose and fix the issue.
```

---

### Debugging Circuit Breaker

**Prompt:**
```
My PaymentService client's circuit breaker is always open. Here's the configuration:
[paste resilience4j config from application.yml]

And here's the client code:
[paste client code]

Help me understand:
1. Why might the circuit be opening?
2. How can I check the current circuit state?
3. What metrics should I look at in Application Insights?
4. How can I adjust the configuration for my use case?
```

---

### Authentication Issues

**Prompt:**
```
I'm getting 401 Unauthorized errors when calling my API endpoints.
I have JWT tokens from Azure AD.

Security configuration:
[paste SecurityConfig.java]

application.yml security section:
[paste security config]

Help me debug:
1. How to verify JWT token is valid?
2. How to check if roles are extracted correctly?
3. How to enable security debug logging?
4. Common misconfigurations to check?
```

---

## Best Practices

### Implementing a New Feature End-to-End

**Prompt:**
```
I want to implement a "Low Stock Alert" feature that:
1. Checks product quantities periodically
2. Sends alerts when quantity < threshold
3. Logs to Application Insights
4. Publishes LowStockEvent for other services

Guide me through the implementation following clean architecture:
- Which layers are involved?
- What commands to run?
- What code to write manually?
- How to test it?
- How to monitor it in production?
```

---

### Applying Resilience Patterns

**Prompt:**
```
I'm calling an external Shipping Service API that is flaky (occasional timeouts and 503 errors).

Requirements:
- Retry transient failures (3 attempts with exponential backoff)
- Circuit breaker to prevent cascade failures
- Fallback to return "shipping unavailable" message
- Track all attempts in Application Insights

Show me:
1. The Resilience4j configuration
2. The client implementation with annotations
3. The fallback method
4. How to test the resilience patterns
5. Application Insights queries to monitor the health
```

---

### Optimizing Performance

**Prompt:**
```
My /api/products endpoint is slow (> 2 seconds response time).

Current implementation:
[paste code]

Help me optimize:
1. Add caching with Spring Cache
2. Implement pagination properly
3. Optimize MongoDB queries
4. Add performance logging
5. Track performance in Application Insights

Show configuration and code changes needed.
```

---

## Conventions Reference

### Naming Conventions

- **Use Cases**: `{Verb}{Noun}UseCase` (e.g., `ProcessOrderUseCase`)
- **Entities**: `{Noun}` (e.g., `Order`, `Product`)
- **Repositories**: `{Entity}Repository` interface, `{DB}{Entity}RepositoryAdapter` implementation
- **DTOs**: `{Entity}Dto`, `{Action}{Entity}RequestDto`, `{Entity}ResponseDto`
- **Events**: `{Entity}{PastTense}Event` (e.g., `OrderCreatedEvent`)
- **Ports**: `{Service}Port` (e.g., `PaymentServicePort`)

### Package Structure

```
com.company.service/
├── domain/               # NO framework dependencies
│   ├── model/
│   │   ├── aggregate/   # DDD aggregates
│   │   ├── entity/      # Domain entities
│   │   └── valueobject/ # Immutable value objects
│   ├── event/           # Domain events
│   └── port/            # Interfaces
│       ├── input/       # Use case interfaces
│       └── output/      # Repository/service interfaces
├── application/         # Depends on domain only
│   ├── usecase/        # Use case implementations
│   └── eventhandler/   # Event handlers
├── infrastructure/      # Framework code
│   ├── adapter/
│   │   ├── persistence/
│   │   ├── client/
│   │   └── messaging/
│   └── config/
└── api/                 # REST layer
    ├── controller/
    ├── dto/
    └── mapper/
```

---

## CLI Commands Quick Reference

```bash
# Initialize project
./springboot-cli.sh init --name SERVICE --package PKG --database DB --features FEATURES

# Add components
./springboot-cli.sh add entity --name NAME --fields "field1:Type1,field2:Type2"
./springboot-cli.sh add usecase --name NAME --aggregate ENTITY
./springboot-cli.sh add repository --entity ENTITY --type jpa|mongo
./springboot-cli.sh add client --name NAME [--circuit-breaker] [--retry] [--rate-limit]
./springboot-cli.sh add camel-route --name NAME --pattern PATTERN

# Generate code
./springboot-cli.sh generate openapi --spec PATH [--update]
./springboot-cli.sh generate contract --provider|--consumer SERVICE

# Validate
./springboot-cli.sh validate architecture
./springboot-cli.sh validate coverage [--threshold PCT] [--mutation]
./springboot-cli.sh validate openapi --spec PATH

# Assess
./springboot-cli.sh assess camel
```

---

**Remember**: This CLI generates production-ready code following best practices. Always review generated code, customize for your specific needs, and add comprehensive tests.
