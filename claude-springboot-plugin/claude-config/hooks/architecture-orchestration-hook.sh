#!/bin/bash

# Architecture Orchestration Pre-Commit Hook
# Validates and auto-fixes architecture violations before commit
# Works with Feature and Architecture agents

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Configuration
ORCHESTRATOR_DIR="$(dirname "$0")/.."
VALIDATION_LOG="/tmp/architecture-validation-$$.log"
AUTO_FIX_LOG="/tmp/architecture-autofix-$$.log"
LEARNING_DB="$ORCHESTRATOR_DIR/data/violations.db"

# Ensure learning directory exists
mkdir -p "$ORCHESTRATOR_DIR/data"

# Function to log violations for learning
log_violation() {
    local file="$1"
    local type="$2"
    local severity="$3"
    local fixed="$4"
    local agent="${AGENT_NAME:-unknown}"

    echo "$(date -Iseconds)|$agent|$file|$type|$severity|$fixed" >> "$ORCHESTRATOR_DIR/data/violations.csv"
}

# Function to check if a class implements a port interface
check_interface_implementation() {
    local file="$1"
    local class_name=$(basename "$file" .java)

    # Skip if not in infrastructure/adapter
    if [[ ! "$file" =~ infrastructure/adapter ]]; then
        return 0
    fi

    # Check if it's a client, repository, or adapter
    if [[ "$file" =~ Client\.java$ ]] || [[ "$file" =~ RepositoryImpl\.java$ ]] || [[ "$file" =~ Adapter\.java$ ]]; then
        # Check if implements any Port interface
        if ! grep -q "implements.*Port" "$file"; then
            echo -e "${RED}✗${NC} Missing interface implementation in $file"
            return 1
        fi
    fi

    return 0
}

# Function to auto-fix missing interface implementation
auto_fix_missing_interface() {
    local file="$1"
    local class_name=$(grep -o "public class [A-Za-z]*" "$file" | awk '{print $3}')
    local port_name="${class_name%Client}Port"

    if [[ "$class_name" =~ RepositoryImpl$ ]]; then
        port_name="${class_name%Impl}"
    elif [[ "$class_name" =~ Adapter$ ]]; then
        port_name="${class_name%Adapter}Port"
    fi

    echo -e "${YELLOW}→${NC} Attempting to auto-fix missing interface in $class_name"

    # Check if port interface exists
    local package=$(grep "^package" "$file" | sed 's/package //;s/;//')
    local domain_package=$(echo "$package" | sed 's/infrastructure.*/domain/')
    local port_package="${domain_package}.port.outbound"
    local port_file=$(echo "$port_package" | tr '.' '/')/"${port_name}.java"
    local port_path="src/main/java/$port_file"

    # Create port interface if it doesn't exist
    if [[ ! -f "$port_path" ]]; then
        echo -e "${BLUE}→${NC} Creating port interface: $port_path"
        mkdir -p "$(dirname "$port_path")"

        # Extract methods from the client class
        local methods=$(grep -A 1 "public.*(" "$file" | grep -v "^--$" | grep -v "class")

        cat > "$port_path" << EOF
package ${port_package};

import ${package}.${class_name};

/**
 * Port interface for ${class_name}
 * Auto-generated by Architecture Orchestration
 */
public interface ${port_name} {
EOF

        # Add method signatures to interface
        echo "$methods" | while IFS= read -r line; do
            if [[ "$line" =~ public.* ]]; then
                # Extract method signature and convert to interface method
                local method_sig=$(echo "$line" | sed 's/{$/;/' | sed 's/public /    /')
                echo "$method_sig" >> "$port_path"
            fi
        done

        echo "}" >> "$port_path"
    fi

    # Update client to implement interface
    sed -i "s/public class ${class_name}/public class ${class_name} implements ${port_name}/" "$file"

    # Add import for the port interface
    if ! grep -q "import.*${port_name}" "$file"; then
        sed -i "/^package/a\\\nimport ${port_package}.${port_name};" "$file"
    fi

    # Add @Override annotations to methods
    sed -i '/public.*(.*).*{/i\    @Override' "$file"

    echo -e "${GREEN}✓${NC} Auto-fixed: $class_name now implements $port_name"
    log_violation "$file" "MISSING_INTERFACE" "CRITICAL" "true"

    # Stage the changes
    git add "$file" "$port_path" 2>/dev/null || true

    return 0
}

# Function to check for Spring annotations in domain layer
check_domain_purity() {
    local violations=0

    echo -e "${BLUE}Checking domain layer purity...${NC}"

    # Find all Java files in domain layer
    local domain_files=$(find src/main/java -path "*/domain/*.java" 2>/dev/null || true)

    for file in $domain_files; do
        # Check for Spring annotations
        if grep -q "@Entity\|@Table\|@Component\|@Service\|@Repository\|@Autowired\|@Value\|@ConfigurationProperties" "$file"; then
            echo -e "${RED}✗${NC} Spring annotations found in domain: $file"
            log_violation "$file" "DOMAIN_SPRING_ANNOTATION" "CRITICAL" "false"
            violations=$((violations + 1))

            # Attempt auto-fix
            auto_fix_domain_annotations "$file"
        fi

        # Check for JPA annotations
        if grep -q "@Id\|@Column\|@ManyToOne\|@OneToMany\|@JoinColumn" "$file"; then
            echo -e "${RED}✗${NC} JPA annotations found in domain: $file"
            log_violation "$file" "DOMAIN_JPA_ANNOTATION" "CRITICAL" "false"
            violations=$((violations + 1))

            # Attempt auto-fix
            auto_fix_domain_annotations "$file"
        fi
    done

    return $violations
}

# Function to auto-fix domain annotations
auto_fix_domain_annotations() {
    local domain_file="$1"
    local class_name=$(basename "$domain_file" .java)

    echo -e "${YELLOW}→${NC} Moving $class_name to proper layers..."

    # Create pure domain model (remove all annotations)
    local temp_file="/tmp/${class_name}_pure.java"
    grep -v "@Entity\|@Table\|@Id\|@Column\|@Component\|@Service\|@Repository\|@Autowired" "$domain_file" > "$temp_file"

    # If it's an entity, create JPA entity in infrastructure
    if grep -q "@Entity" "$domain_file"; then
        local infra_path="src/main/java/$(echo "$domain_file" | sed 's|domain/model|infrastructure/adapter/persistence/entity|' | sed 's|.java|JpaEntity.java|')"
        mkdir -p "$(dirname "$infra_path")"

        # Create JPA entity
        cp "$domain_file" "$infra_path"
        sed -i "s/class ${class_name}/class ${class_name}JpaEntity/" "$infra_path"

        echo -e "${GREEN}✓${NC} Created JPA entity: $infra_path"

        # Create mapper
        create_entity_mapper "$class_name"
    fi

    # Replace domain file with pure version
    mv "$temp_file" "$domain_file"

    echo -e "${GREEN}✓${NC} Cleaned domain model: $domain_file"

    # Stage changes
    git add "$domain_file" 2>/dev/null || true
}

# Function to create entity mapper
create_entity_mapper() {
    local entity_name="$1"
    local mapper_path="src/main/java/infrastructure/adapter/persistence/mapper/${entity_name}Mapper.java"

    mkdir -p "$(dirname "$mapper_path")"

    cat > "$mapper_path" << EOF
package infrastructure.adapter.persistence.mapper;

import domain.model.${entity_name};
import infrastructure.adapter.persistence.entity.${entity_name}JpaEntity;
import org.springframework.stereotype.Component;

@Component
public class ${entity_name}Mapper {

    public ${entity_name} toDomain(${entity_name}JpaEntity entity) {
        if (entity == null) return null;

        // TODO: Implement mapping logic
        return new ${entity_name}();
    }

    public ${entity_name}JpaEntity toEntity(${entity_name} domain) {
        if (domain == null) return null;

        // TODO: Implement mapping logic
        return new ${entity_name}JpaEntity();
    }
}
EOF

    echo -e "${GREEN}✓${NC} Created mapper: $mapper_path"
    git add "$mapper_path" 2>/dev/null || true
}

# Function to validate dependency directions
check_dependency_directions() {
    local violations=0

    echo -e "${BLUE}Checking dependency directions...${NC}"

    # Check if domain imports from other layers (should not happen)
    local domain_files=$(find src/main/java -path "*/domain/*.java" 2>/dev/null || true)

    for file in $domain_files; do
        if grep -q "import.*\.infrastructure\.\|import.*\.application\.\|import.*\.api\." "$file"; then
            echo -e "${RED}✗${NC} Domain depends on other layers: $file"
            log_violation "$file" "DOMAIN_DEPENDENCY_VIOLATION" "CRITICAL" "false"
            violations=$((violations + 1))
        fi
    done

    return $violations
}

# Function to run ArchUnit tests if available
run_archunit_tests() {
    echo -e "${BLUE}Running ArchUnit tests...${NC}"

    if [[ -f "pom.xml" ]]; then
        # Run only architecture tests
        mvn test -Dtest="*ArchitectureTest" -DfailIfNoTests=false > "$VALIDATION_LOG" 2>&1 || {
            echo -e "${RED}✗${NC} Architecture tests failed. Check $VALIDATION_LOG for details."
            return 1
        }
        echo -e "${GREEN}✓${NC} Architecture tests passed"
    fi

    return 0
}

# Function to generate validation report
generate_report() {
    local report_file="$ORCHESTRATOR_DIR/data/validation-report-$(date +%Y%m%d-%H%M%S).json"

    cat > "$report_file" << EOF
{
  "timestamp": "$(date -Iseconds)",
  "agent": "${AGENT_NAME:-unknown}",
  "validation_results": {
    "interface_checks": $1,
    "domain_purity": $2,
    "dependency_checks": $3,
    "archunit_tests": $4
  },
  "auto_fixes_applied": $5,
  "commit_allowed": $6
}
EOF

    echo -e "${BLUE}Report saved:${NC} $report_file"
}

# Main validation flow
main() {
    echo -e "${BLUE}═══════════════════════════════════════════════════════${NC}"
    echo -e "${BLUE}    Architecture Orchestration Pre-Commit Validation    ${NC}"
    echo -e "${BLUE}═══════════════════════════════════════════════════════${NC}"

    local total_violations=0
    local auto_fixes=0

    # Get staged files
    local staged_files=$(git diff --cached --name-only --diff-filter=ACM | grep "\.java$" || true)

    if [[ -z "$staged_files" ]]; then
        echo -e "${YELLOW}No Java files staged for commit${NC}"
        exit 0
    fi

    # 1. Check interface implementations
    echo -e "\n${BLUE}[1/4] Checking interface implementations...${NC}"
    local interface_violations=0
    for file in $staged_files; do
        if ! check_interface_implementation "$file"; then
            interface_violations=$((interface_violations + 1))
            if auto_fix_missing_interface "$file"; then
                auto_fixes=$((auto_fixes + 1))
            fi
        fi
    done

    # 2. Check domain layer purity
    echo -e "\n${BLUE}[2/4] Checking domain layer purity...${NC}"
    domain_violations=$(check_domain_purity || echo $?)

    # 3. Check dependency directions
    echo -e "\n${BLUE}[3/4] Checking dependency directions...${NC}"
    dependency_violations=$(check_dependency_directions || echo $?)

    # 4. Run ArchUnit tests
    echo -e "\n${BLUE}[4/4] Running architecture tests...${NC}"
    archunit_result=0
    run_archunit_tests || archunit_result=1

    # Calculate total violations
    total_violations=$((interface_violations + domain_violations + dependency_violations))

    # Generate report
    generate_report \
        "$interface_violations" \
        "$domain_violations" \
        "$dependency_violations" \
        "$archunit_result" \
        "$auto_fixes" \
        "$((total_violations == 0 ? 1 : 0))"

    # Final decision
    echo -e "\n${BLUE}═══════════════════════════════════════════════════════${NC}"
    if [[ $total_violations -eq 0 ]] && [[ $archunit_result -eq 0 ]]; then
        echo -e "${GREEN}✓ All architecture validations passed!${NC}"
        echo -e "${GREEN}✓ Applied $auto_fixes auto-fixes${NC}"

        # Provide learning feedback if fixes were applied
        if [[ $auto_fixes -gt 0 ]]; then
            echo -e "\n${YELLOW}Learning Points:${NC}"
            echo "  • Always implement port interfaces for infrastructure components"
            echo "  • Keep domain layer free from framework dependencies"
            echo "  • Follow Clean Architecture dependency rules"
        fi

        exit 0
    else
        echo -e "${RED}✗ Architecture violations detected!${NC}"
        echo -e "  Total violations: $total_violations"
        echo -e "  Auto-fixes applied: $auto_fixes"
        echo -e "\n${YELLOW}Please fix remaining violations before committing.${NC}"
        echo -e "Run ${BLUE}./bin/orchestrator.sh validate --fix${NC} for detailed report."

        exit 1
    fi
}

# Clean up on exit
trap "rm -f $VALIDATION_LOG $AUTO_FIX_LOG" EXIT

# Run main validation
main "$@"